Contexto
Ya tengo un backend base en Flask con:

Multi-tenant (empresas y usuarios con roles ADMIN/USER).

Autenticaci√≥n JWT.

Gesti√≥n de integraciones externas (Palo Alto, Splunk, Meraki, Wazuh).

Tickets CRUD y auditor√≠a.

Documentaci√≥n OpenAPI.

Ahora necesito extender este backend para soportar el Dashboard de seguridad (como en mis mocks), donde se muestra:

Estado de sistemas conectados (Online/Warning/Alert).

Alertas activas y resoluci√≥n.

Vulnerabilidades y parcheo.

Anal√≠ticas: tendencias de incidentes, tiempos de respuesta, distribuci√≥n de vulnerabilidades.

Adem√°s quiero integrar Grafana para poder extraer datos de paneles o m√©tricas que empresas ya tengan ah√≠ y unificarlos en el dashboard.

üîß Requerimientos t√©cnicos

Ampliar el modelo integrations

Agregar campo type o capabilities (ej. ALERTING, METRICS, VULNERABILITY_FEED).

Permitir un campo config (JSON) para almacenar URLs de APIs, UID de dashboards/paneles, etc.

Mantener keyvault_secret_id para tokens/keys seguros.

Crear m√≥dulo providers/grafana.py

Funciones para consumir la API de Grafana con tokens desde Key Vault:

list_dashboards()

fetch_panel_data(dashboard_uid, panel_id, from_ts, to_ts)

Preparar patr√≥n gen√©rico para otros proveedores de m√©tricas si se agregan luego.

Endpoints nuevos para dashboards

GET /systems/status ‚Üí resumen: online, warning, alert, total.

GET /systems ‚Üí lista de sistemas conectados con estado y detalles.

GET /alerts/active ‚Üí alertas recientes (con severidad y origen).

POST /alerts/{id}/resolve ‚Üí marcar alerta resuelta.

GET /vulnerabilities ‚Üí listado con estado (open, patching, resolved).

POST /vulnerabilities/{id}/patch ‚Üí iniciar proceso de parcheo (sin agentes a√∫n).

GET /analytics/incidents ‚Üí incidentes por severidad √∫ltimas 24h.

GET /analytics/response-time ‚Üí tiempo promedio de respuesta.

GET /analytics/vulnerability-distribution ‚Üí distribuci√≥n de CVEs activas.

Normalizador de datos

Cada provider (Palo Alto, Splunk, Grafana‚Ä¶) debe devolver un formato est√°ndar para el front:

{
  "system": "Palo Alto Firewall",
  "status": "alert",
  "alerts": [
    { "id": "123", "title": "Unusual Traffic Detected", "time": "2025-10-07T12:00:00Z", "severity": "high", "source": "Palo Alto" }
  ],
  "metrics": { "uptime": 99.9, "response_time_avg": 15 }
}


El front podr√° renderizar sin preocuparse por cada API espec√≠fica.

(Opcional) Tiempo real

Si es f√°cil, agrega soporte a WebSocket/Flask-SocketIO para alertas en vivo.

Si no, mantener polling con par√°metros ?since=timestamp.

Auditor√≠a

Loggear cada acceso a datos de integraciones y consultas de m√©tricas/alertas.

Documentaci√≥n

Actualiza el archivo openapi/openapi.yaml para incluir estos nuevos endpoints y modelos de respuesta.

Frontend de prueba

Si necesitas crear una vista m√≠nima para validar endpoints, hazlo simple y d√©jalo en /basic_frontend.

Nada complejo: solo HTML/JS con fetch para mostrar JSON de los nuevos endpoints.

‚ö†Ô∏è Instrucciones importantes

NO uses Streamlit ni frameworks de dashboards avanzados; mant√©nlo backend puro.

Mant√©n la estructura modular existente (auth, companies, tickets, integrations, providers, common, openapi).

Implementa los nuevos endpoints como recursos REST claros.

Mant√©n la autenticaci√≥n JWT igual que el resto de la app.

Usa Key Vault para leer tokens de Grafana y otros proveedores.

Deja todo preparado para que despu√©s SOPHIA y VICTORIA puedan consumir estos endpoints como contexto.

‚úÖ Resultado esperado

Backend Flask extendido con soporte completo para dashboards, alertas, vulnerabilidades y m√©tricas.

Integraci√≥n funcional con Grafana (providers/grafana.py) para traer datos de paneles o m√©tricas.

OpenAPI actualizado con todos los endpoints nuevos.

(Opcional) Front m√≠nimo para testear las nuevas rutas.