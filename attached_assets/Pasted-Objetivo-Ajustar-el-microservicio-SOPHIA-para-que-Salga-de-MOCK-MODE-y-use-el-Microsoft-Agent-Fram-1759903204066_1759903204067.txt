Objetivo
Ajustar el microservicio SOPHIA para que:

Salga de MOCK MODE y use el Microsoft Agent Framework con credenciales reales por empresa.

Mantenga una estructura limpia y modular para SOPHIA.

Deje ya preparada la arquitectura para el handoff a VictorIA (sin implementar la l√≥gica completa, solo estructura y puntos de extensi√≥n).

üèóÔ∏è Estructura de archivos esperada
sophia_service/
  app.py                # Flask app y endpoints /chat, /config/test, /refresh
  config.py             # Configuraci√≥n general y manejo de cache
  sophia/
      __init__.py
      agent_loader.py   # Inicializa SOPHIA din√°micamente seg√∫n tenant
      memory.py         # Manejo de sesiones (thread_id, memoria a futuro)
      rag_tools.py      # Integraci√≥n RAG con azure-search-documents
      mock_integrations.py # Palo Alto, Splunk, Grafana simulados
      intent_router.py  # Detecta intenci√≥n (consulta normal vs acci√≥n)
      handoff.py        # Puntos de extensi√≥n para derivar a VictorIA
  victor/
      __init__.py
      client_stub.py    # Cliente stub para enviar tickets a VictorIA (mock)
      ticket_models.py  # Modelos de datos del ticket

‚ö° Comportamiento esperado de SOPHIA

1. Inicio din√°mico

Al recibir un company_id y agent_access_key:

Llama a /agents/auth/token para obtener credenciales reales.

Si encuentra azure_openai_endpoint y azure_openai_key v√°lidos ‚Üí inicializa un ProjectClient del Agent Framework con azure-ai-projects.

Configura RAG con azure-search-documents si hay search_endpoint y search_key.

Si falta algo ‚Üí entra a MOCK MODE.

2. Chat (/chat)

Usa un intent_router para decidir:

Pregunta informativa ‚Üí responder con RAG (o mock si est√° en modo simulado).

Solicitud de acci√≥n ‚Üí NO ejecuta, sino llama a handoff.create_ticket_stub() y devuelve un mensaje al usuario:

‚ÄúEste caso requiere escalaci√≥n a VictorIA. Ticket preliminar creado.‚Äù

A futuro, el archivo handoff.py invocar√° a VictorIA real.

3. Test config (/config/test)

Crea un cliente de ProjectClient con los datos recibidos.

Responde si la configuraci√≥n es v√°lida (modo real) o no (modo mock).

4. Cache

Configuraci√≥n por company-{id} para no reconsultar en cada request.

Endpoint /refresh para invalidar cache.

üß™ Tools externas (por ahora mockeadas)

Archivo mock_integrations.py con funciones como:

def get_palo_alto_alerts():
    return [{"id": "pa1", "severity": "high", "message": "Mock Palo Alto alert"}]

def get_splunk_logs():
    return [{"id": "sp1", "message": "Mock Splunk log"}]

def get_grafana_metrics():
    return {"cpu": 42, "memory": 73}


SOPHIA puede ‚Äúllamar‚Äù estas tools pero por ahora devuelven datos ficticios.

üîß Handoff a VictorIA (estructura preparada)

Crear m√≥dulo victor/ con:

client_stub.py: funci√≥n send_ticket_to_victoria(ticket_data) que por ahora solo imprime/loggea que el ticket ser√≠a enviado.

ticket_models.py: dataclass TicketDraft con campos subject, description, severity, context.

SOPHIA, en el intent_router, cuando detecte intenci√≥n de acci√≥n:

from sophia.handoff import create_ticket_stub
ticket = create_ticket_stub(user_message, context)


Responder al usuario: ‚ÄúEste caso requiere intervenci√≥n de VictorIA. Ticket preliminar creado.‚Äù

(M√°s adelante se reemplazar√° el stub por la implementaci√≥n real de VictorIA).

üîê Seguridad

Mantener credenciales de Azure solo en Key Vault (el backend devuelve IDs y secretos).

No imprimir keys completas en logs.

Seguir usando access keys con bcrypt.

‚úÖ Resultado esperado

SOPHIA deja el modo mock si existen credenciales Azure correctas.

Si no hay credenciales ‚Üí sigue mostrando [MOCK MODE].

C√≥digo organizado para poder a√±adir f√°cilmente las tools reales y a VictorIA despu√©s.

Flujo de intenci√≥n ‚Üí posible derivaci√≥n a VictorIA ya listo (stub).

/config/test permite validar configuraci√≥n antes de usar.

NO crear UI nueva. Mantener el frontend b√°sico actual.
Solo actualizar el servicio SOPHIA.